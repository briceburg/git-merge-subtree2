#!/bin/bash
source "$( dirname $( readlink -e $0 ) )/lib/lib.sh"


#
# Constants
MY_BRANCH=$( git symbolic-ref --short HEAD )
STATE_FILE="$GIT_REPO/GIT_SUBPROJECT_CONTINUE"
PULL_MARKER="git-subproject-pull:"
PUSH_MARKER="git-subproject-push:"

#
# Input Variables
THEIR_BRANCH=
MY_PREFIX=
THEIR_PREFIX=
BASE_PREFIX=
MESSAGE=
HISTORY_FORMAT="medium"
MERGE_FILE_CONFLICT_STYLE=""
MERGE_FILE_MODE=""

#
# Context Variables
LAST_PULL_MY_REV=
LAST_PULL_MY_PREFIX=
LAST_PULL_THEIR_REV=
LAST_PULL_THEIR_PREFIX=
LAST_PUSH_MY_REV=
LAST_PUSH_MY_PREFIX=
LAST_PUSH_THEIR_REV=
LAST_PUSH_THEIR_PREFIX=


#
# Help

function help() {
    >&2 cat << EOF
Include another branch or a subdirectory thereof as subdirectory of the
current branch. By refering to remote branches, other repositories can be
included as well. Subproject merges like `git merge --squash`, so that the
history does not become cluttered. Source branch and commit are remembered
within the merge commit's message to simplify later updates. A subproject can
also be merged back into the source branch.
    
git subproject init <my-prefix> (--their-branch=<their-branch> | <their-branch>) [-m <message>] [--format=<format>] [--their-prefix=<their-prefix>]
git subproject pull <my-prefix> [-m <message>] [--format=<format>] [--their-prefix=<their-prefix>] [--their-branch=<their-branch>] [--base=<base>] [--base-prefix=<base-prefix>] [--diff3] [--ours|--theirs|--union]
git subproject push <my-prefix> [-m <message>] [--format=<format>]

Init:
    Copy a remote branch's content to a subdirectory <my-prefix> of the current
    branch. The command will refuse to run if <my-prefix> already exists.
    
       my-prefix: mandatory - subdirectory in which their branch will be
                  included
    their-branch: mandatory - branch to be merged into a subdirectory of the
                  current branch
    their-prefix: optional - limit merging to this subdirectory of their
                  branch
         message: optional - custom commit message
          format: optional - pass to \`git log\`'s format option when appending
                  a description of the merged history to the commit message; use
                  \`--format=\` to suppress the history

Pull:
    Update a subproject by merging changes from the upstream branch.
    This command can also be used to change the name and/or prefix of the
    upstream branch.
    
       my-prefix: mandatory - subdirectory containing an existing subproject
    their-branch: optional - change the name of the upstream branch for now and
                  the future; you might need to specify a different base for
                  merging (see below)
            base: optonal - overwrite the common-ancestor used for 3way merge;
                  this might be usefull if the source branch's history has been
                  rewritten; note - no history can be embedded into the commit
                  message when this option is used
    their-prefix: optional - change their prefix if the directory has been
                  renamed since the last update
     base-prefix: optional - overwrite the prefix applied to the common
                  ancestor; this might be necessary when specifying a custom
                  base
         message: optional - custom commit message
          format: optional - pass to \`git log\`'s format option when appending
                  a description of the merged history to the commit message; use
                  \`--format=\` to suppress the history
           diff3: optional - show conflicts in "diff3" style, that is the common
                  ancestor's version is included in confict markers
            ours:
          theirs:
           union: optional - resolve conflicts favouring our (or their or both)
                  side of the lines.
           
Push:
    Push local changes to the upstream branch. Refused if the upstream branch
    has changed since the last update.
    
       my-prefix: mandatory - subdirectory containing an existing subproject
         message: optional - custom commit message
          format: optional - pass to \`git log\`'s format option when appending
                  a description of the merged history to the commit message; use
                  \`--format=\` to suppress the history
                  
Continue:
    Continue a pull/push operation after merge conflicts have been resolved.
EOF

    if [[ -n $1 ]]; then
        exit $1
    fi
    
    exit $CRITICAL_EXIT_CODE
}


#
# Functions

# Commit the merged working directory or save the current script state to be
# picked up by `git subproject continue` and abort with exit code
# $CAN_CONTINUE_EXIT_CODE.
function commit() {
    if ! git diff --no-ext-diff --quiet --exit-code --diff-filter=U; then
        >&2 echo "ERROR: Committing is not possible because you have unmerged files."
        >&2 echo "HINT: Fix them up in the work tree, and then use 'git add/rm <file>'"
        >&2 echo "HINT: as appropriate to mark resolution. Finally continue with"
        >&2 echo "HINT: \`git subproject continue\`."
        
        echo "STATE_REV=$(git rev-list HEAD -1)" > "$STATE_FILE"
        
        local STATE_VARS=( "BASE_PREFIX" "HISTORY_FORMAT" "LAST_PULL_MY_REV" "LAST_PULL_THEIR_PREFIX" "LAST_PULL_THEIR_REV" "LAST_PUSH_MY_REV" "LAST_PUSH_THEIR_PREFIX" "LAST_PUSH_THEIR_REV"  "MESSAGE" "MY_BRANCH" "MY_PREFIX" "THEIR_BRANCH" "THEIR_PREFIX")
        for var in "${STATE_VARS[@]}"; do
            declare -p $var >> "$STATE_FILE"
        done
        
        exit $CAN_CONTINUE_EXIT_CODE
    fi

    git commit -m "$MESSAGE"
}

# Add history and subproject markers to the commit message $MESSAGE. A default
# message is created when $MESSAGE is empty.
# Arguments: <marker> <my_branch> <my_prefix> <their_prefix> <last_known_their_rev>
#           <marker>: indicates that the commit is a subproject commit (example:
#                     git-subproject-pull)
#     <local_branch>: target branch
#     <local_prefix>: target branch prefix (subdirectory)
#    <remote_branch>: source branch
#    <remote_prefix>: source branch prefix (subdirectory)
#    <last_known_their_rev>: log message from this revision up to the tip of
#                     their_branch are included in the commit message; if
#                     unspecified the full history is considered; the history
#                     format is taken from $HISTORY_FORMAT
function finalize-message() {
    local MARKER="$1"
    local LOCAL_BRANCH="$2"
    local LOCAL_PREFIX="$3"
    local REMOTE_BRANCH="$4"
    local REMOTE_PREFIX="$5"
    local LAST_KNOWN_REMOTE_REV="$6"

    local REMOTE_REV=$( git rev-parse $REMOTE_BRANCH )
    local MARKER_LINE="$MARKER -Xmy-prefix=\"$LOCAL_PREFIX\" -Xtheir-branch=\"$REMOTE_BRANCH\" -Xtheir-prefix=\"$REMOTE_PREFIX\" -Xtheir-rev=\"$REMOTE_REV\""
    
    if [[ -z "$MESSAGE" ]]; then
        local REMOTE_DESC=
        [[ -n "$REMOTE_PREFIX" ]] && REMOTE_DESC="$REMOTE_BRANCH:$REMOTE_PREFIX" || REMOTE_DESC="$REMOTE_BRANCH:*"
        
        local LOCAL_DESC=
        [[ -n "$LOCAL_PREFIX" ]] && LOCAL_DESC="$LOCAL_BRANCH:$LOCAL_PREFIX" || LOCAL_DESC="LOCAL_BRANCH:*"
    
        MESSAGE="Merge '$REMOTE_DESC' into '$LOCAL_DESC'"
    fi
    
    if [[ -n "$LAST_KNOWN_REMOTE_REV" ]]; then
        local LIMIT="^$LAST_KNOWN_REMOTE_REV"
        if [[ "$LAST_KNOWN_REMOTE_REV" == "$EMPTY_TREE" ]]; then
            LIMIT=""
        fi
        
        local HISTORY=$( git log --format="$HISTORY_FORMAT" $REMOTE_BRANCH $LIMIT -- $REMOTE_PREFIX | grep -v -E "^\s*($PULL_MARKER|$PUSH_MARKER)" )
        if [[ -n "$HISTORY" ]]; then
            MESSAGE+="$NL$NL$HISTORY"
        fi
    fi
    
    MESSAGE+="$NL$NL$MARKER_LINE"
}

# Parse history to figure out context variables: subproject commits are marked
# with either $PUSH_MARKERs or $PULL_MARKERs
function get-context() {
    if [[ ! -d "$MY_PREFIX" ]]; then
        >&2 echo "ERROR: Prefix directory '$MY_PREFIX' not found."
        return $CRITICAL_EXIT_CODE
    fi

    LAST_PULL_MY_REV=$( git rev-list -1 --first-parent "--grep=^$PULL_MARKER.*-Xmy-prefix=\"$MY_PREFIX\"" HEAD )
    if [[ -z "$LAST_PULL_MY_REV" ]]; then
        >&2 echo "ERROR: Subproject $MY_PREFIX not found."
        return $CRITICAL_EXIT_CODE
    fi
    
    local MY_CONFIG=$( git log -1 --format=%s%n%b $LAST_PULL_MY_REV | grep "^$PULL_MARKER" | sed -e "s/^$PULL_MARKER\s*//" )
    for opt in $MY_CONFIG; do
        local VAL=$( echo "${opt##*=}" | xargs )
        case "$opt" in
            -Xmy-prefix=*)
                LAST_PULL_MY_PREFIX="$VAL"
                ;;
            -Xtheir-prefix=*)
                set-if-zero "THEIR_PREFIX" "$VAL"
                LAST_PULL_THEIR_PREFIX="$VAL"
                ;;
            -Xtheir-branch=*)
                set-if-zero "THEIR_BRANCH" "$VAL"
                ;;
            -Xtheir-rev=*)
                LAST_PULL_THEIR_REV="$VAL"
                ;;
        esac
    done
    
    resolve-branch "THEIR_BRANCH" || return $CRITICAL_EXIT_CODE
    LAST_PUSH_THEIR_REV=$( git rev-list -1 --first-parent --perl-regexp "--grep=^$PUSH_MARKER(?=.*-Xtheir-prefix=\"$MY_PREFIX\")(?=.*-Xtheir-branch=\"$MY_BRANCH\")" $THEIR_BRANCH --not $BASE )
    if [[ -n "$LAST_PUSH_THEIR_REV" ]]; then
        local THEIR_CONFIG=$( git log -1 --format=%s%n%b $LAST_PUSH_THEIR_REV | grep "^$PUSH_MARKER" | sed -e "s/^$PUSH_MARKER\s*//")
        
        for opt in $THEIR_CONFIG; do
            local VAL=$( echo "${opt##*=}" | xargs )
            case "$opt" in
                -Xtheir-rev=*)
                    LAST_PUSH_MY_REV="$VAL"
                    ;;
                -Xtheir-prefix=*)
                    LAST_PUSH_MY_PREFIX="$VAL"
                    ;;
                -Xmy-prefix=*)
                    LAST_PUSH_THEIR_PREFIX="$VAL"
                    ;;
                *);;
            esac
        done
    fi
}

# Merge like subtree2 strategy
function merge() {
    local LOCAL_BRANCH="$1"
    local LOCAL_PREFIX="$2"
    local REMOTE_BRANCH="$3"
    local REMOTE_PREFIX="$4"
    local BASE_REV="$5"
    local BASE_PREFIX="$6"
    
    # do the merge
    shift-prefix-directory "BASE_REV" "$BASE_PREFIX" "$LOCAL_BRANCH" "$LOCAL_PREFIX" || return $?
    shift-prefix-directory "REMOTE_BRANCH" "$REMOTE_PREFIX" "$LOCAL_BRANCH" "$LOCAL_PREFIX" || return $?
    merge-resolve "$LOCAL_BRANCH" "$REMOTE_BRANCH" "$BASE_REV" || return $?
       
    if [[ -z "$(git status --porcelain)" ]]; then
        >&2 echo "ERROR: No changes to pull/push."
        return $CRITICAL_EXIT_CODE
    fi
}

# Merge and commit the merged working directory -or- when in case of remaining
# conflicts, save the current script stateto be picked up by 
#`git subproject continue` and abort with exit code $CAN_CONTINUE_EXIT_CODE.
function merge-and-commit() {
    local MARKER="$1"
    local LOCAL_BRANCH="$2"
    local LOCAL_PREFIX="$3"
    local REMOTE_BRANCH="$4"
    local REMOTE_PREFIX="$5"
    local BASE_REV="$6"
    local BASE_PREFIX="$7"
    local LAST_KNOWN_THEIR_REV="$8"
    
    finalize-message "$MARKER" "$LOCAL_BRANCH" "$LOCAL_PREFIX" "$REMOTE_BRANCH" "$REMOTE_PREFIX" "$LAST_KNOWN_THEIR_REV" || return $?
    
    merge "$LOCAL_BRANCH" "$LOCAL_PREFIX" "$REMOTE_BRANCH" "$REMOTE_PREFIX" "$BASE_REV" "$BASE_PREFIX"
    local MERGE_RESULT=$?
    
    if [[ $MERGE_RESULT -ne $CRITICAL_EXIT_CODE ]]; then
        commit
    else
        return $MERGE_RESULT
    fi
}

# Read command line arguments
function read-arguments() {
    local COMMON_ARGS=( "-m" "--message" "--format" )
    local INIT_ARGS=( "${COMMON_ARGS[@]}" "--their-branch" "--their-prefix" )
    local PULL_ARGS=( "${COMMON_ARGS[@]}" "--their-branch" "--base" "--their-prefix" "--base-prefix" "--diff3" "--ours" "--theirs" "--union")
    local PUSH_ARGS=( "${COMMON_ARGS[@]}" )
    local CONTINUE_ARGS=( )
    local -n ALLOWED_ARGS

    function ensure-allowed() {
        for a in "${ALLOWED_ARGS[@]}"; do
            if [[ "$1" == "$a"* ]]; then
                return 0
            fi
        done
        
        help
    }
    
    if [[ "$@" == *help* ]]; then 
        help 0
    fi

    # check mode
    MODE="$1"
    case "$MODE" in
        init|pull|push)
            [[ $# -lt 2 ]] && help
            MY_PREFIX=$(normalize-prefix "$2")
            shift 2
            ;;
        continue)
            [[ $# -gt 1 ]] && help
            shift
            ;;
        *)
            help
            ;;
    esac
    
    # select argument set
    ALLOWED_ARGS="${MODE^^}_ARGS"

    # treat THEIR_BRANCH special if in mode `init`
    if [[ "$MODE" == "init" && "$1" != --* ]]; then
        THEIR_BRANCH="$1"
        shift
    fi

    # parse args
    while [[ $# -gt 0 ]]
    do
        ensure-allowed $1
        local VAL="${1##*=}"
        
        case "$1" in
            --base=*)
                BASE="$VAL"
                ;;
            --base-prefix=*)
                BASE_PREFIX=$(normalize-prefix "$VAL")
                ;;
            --diff3)
                MERGE_FILE_CONFLICT_STYLE="-Xdiff3"
                ;;
            --format=*)
                HISTORY_FORMAT="$VAL"
                ;;
            -m)
                MESSAGE=$2
                shift
                ;;
            --message=*)
                MESSAGE="$VAL"
                ;;
            --ours)
                MERGE_FILE_MODE="-Xours"
                ;;
            --theirs)
                MERGE_FILE_MODE="-Xtheirs"
                ;;
            --their-branch=*)
                THEIR_BRANCH="$VAL"
                ;;
            --their-prefix=*)
                THEIR_PREFIX=$(normalize-prefix "$VAL")
                ;;
            --union)
                MERGE_FILE_MODE="-Xunion"
                ;;
            *)
                help
                ;;
        esac
        shift # past argument or value
    done

    [[ "$MODE" == "continue" || -n "$MY_PREFIX" ]] || help
}


#
# Mode implementation

function do-init() {
    if [[ -e "$MY_PREFIX" ]]; then
        >&2 echo "ERROR: Prefix directory '$MY_PREFIX' already exists."
        return $CRITICAL_EXIT_CODE
    fi

    resolve-branch "THEIR_BRANCH" || return $CRITICAL_EXIT_CODE
    local THEIR_REV=$( git rev-parse $THEIR_BRANCH )
    local BASE_REV="$EMPTY_TREE"
    local BASE_PREFIX=""
    local LAST_KNOWN_THEIR_REV="$EMPTY_TREE"
    
    merge-and-commit "$PULL_MARKER" "$MY_BRANCH" "$MY_PREFIX" "$THEIR_BRANCH" "$THEIR_PREFIX" "$BASE_REV" "$BASE_PREFIX" "$LAST_KNOWN_THEIR_REV" || return $?
}

function finish-init() { 
    :
}

function do-pull() {
    get-context || return $?
       
    # Determine base (first applicable option is used)
    # 1. explicit BASE given by user
    # 2. LAST_PUSH_MY_REV is newer than LAST_PULL_MY_REV:
    #    use LAST_PUSH_MY_REV
    # 3. use LAST_PULL_THEIR_REV
    # Determine base prefix (first applicable option is used)
    # 1. explicit BASE_PREFIX given by user
    # 2. LAST_PUSH_MY_REV is newer than LAST_PULL_MY_REV: use LAST_PUSH_THEIR_PREFIX
    # 3. LAST_PULL_THEIR_PREFIX
    local PULL_BASE="$BASE"
    local PULL_BASE_PREFIX="$BASE_PREFIX"
    local LAST_KNOWN_THEIR_REV=
    if [[ -n $LAST_PUSH_MY_REV && ( $LAST_PUSH_MY_REV == $LAST_PULL_MY_REV || -n $( git rev-list --first-parent $LAST_PULL_MY_REV..$LAST_PUSH_MY_REV ) ) ]]; then
        set-if-zero "PULL_BASE" "$LAST_PUSH_MY_REV"
        set-if-zero "PULL_BASE_PREFIX" "$LAST_PUSH_MY_PREFIX"
        LAST_KNOWN_THEIR_REV="$LAST_PUSH_THEIR_REV"
    else
        set-if-zero "PULL_BASE" "$LAST_PULL_THEIR_REV"
        set-if-zero "PULL_BASE_PREFIX" "$LAST_PULL_THEIR_PREFIX"
        LAST_KNOWN_THEIR_REV="$LAST_PULL_THEIR_REV"
    fi
    
    if [[ -n "$BASE" ]]; then
        LAST_KNOWN_THEIR_REV=
    fi
    
    merge-and-commit "$PULL_MARKER" "$MY_BRANCH" "$MY_PREFIX" "$THEIR_BRANCH" "$THEIR_PREFIX" "$PULL_BASE" "$PULL_BASE_PREFIX" "$LAST_KNOWN_THEIR_REV" || return $?
}

function finish-pull() { 
    :
}

function do-push() {
    get-context  || return $?
    
    local PUSH_BASE=
    local PUSH_BASE_PREFIX=
    local LAST_KNOWN_THEIR_REV=
    LAST_KNOWN_MY_REV="$LAST_PUSH_MY_REV"
    if [[ -n $LAST_PUSH_MY_REV && ( $LAST_PUSH_MY_REV == $LAST_PULL_MY_REV || -n $( git rev-list --first-parent $LAST_PULL_MY_REV..$LAST_PUSH_MY_REV ) ) ]]; then
        # Last PUSH is newer than last PULL
        #
        PUSH_BASE="$LAST_PUSH_MY_REV"
        PUSH_BASE_PREFIX="$LAST_PUSH_MY_PREFIX"
        LAST_KNOWN_THEIR_REV="$LAST_PUSH_THEIR_REV"
    else
        # LAST PULL is newest
        #
        PUSH_BASE="$LAST_PULL_THEIR_REV"
        PUSH_BASE_PREFIX="$LAST_PULL_THEIR_PREFIX"
        LAST_KNOWN_THEIR_REV="$LAST_PULL_THEIR_REV"
    fi
    
    # refuse to push if their side has unknown changes
    if ! git diff --no-ext-diff --quiet --exit-code $LAST_KNOWN_THEIR_REV..$THEIR_BRANCH -- "$THEIR_PREFIX"; then
        >&2 echo "ERROR: Their branch '$THEIR_BRANCH' has changes that have not been pulled."
        >&2 echo "ERROR: You need to pull these changes first!"
        exit $CRITICAL_EXIT_CODE
    fi
    
    if [[ -z "$LAST_KNOWN_MY_REV" ]]; then 
        LAST_KNOWN_MY_REV="$EMPTY_TREE"
    fi
    
    git checkout -q "$THEIR_BRANCH"
    merge-and-commit "$PUSH_MARKER" "$THEIR_BRANCH" "$THEIR_PREFIX" "$MY_BRANCH" "$MY_PREFIX" "$PUSH_BASE" "$PUSH_BASE_PREFIX" "$LAST_KNOWN_MY_REV" || return $?
}

function finish-push() {
    git checkout -q "$MY_BRANCH"
}

function do-continue() {
    if [[ ! -f "$STATE_FILE" ]]; then
        >&2 echo "ERROR: Nothing to continue!"
        return $CRITICAL_EXIT_CODE
    fi
    
    . "$GIT_REPO/GIT_SUBPROJECT_CONTINUE"
    if [[ "$STATE_REV" != $(git rev-list HEAD -1) ]]; then
        >&2 echo "ERROR: Nothing to continue!"
        return $CRITICAL_EXIT_CODE
    fi
    
    commit
    
    rm "$STATE_FILE"
}

function finish-continue() { 
    :
}


#
# Main

# Go to root directory of the working tree
cd $(git rev-parse --show-toplevel)

read-arguments "$@"
if [[ "$MODE" != "continue" ]]; then
    fail-if-dirty
fi

eval "do-$MODE"
DO_STATUS=$?

eval "finish-$MODE $DO_STATUS"
FINISH_STATUS=$?

[[ $DO_STATUS -ne 0 ]] && exit $DO_STATUS || exit $FINISH_STATUS